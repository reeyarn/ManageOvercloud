# Import Python's native modules
import datetime
import os
import gzip 
from typing import Union

# Import PIP packages
import logging
import dropbox


class ManageOvercloud(object):
    """
    This class replaces local file IO functions such as os.path.isfile(), os.path.isdir(), open(...).read(), open(...).write() 
        and operates flexibles on local storage and dropbox cloud.
    When provided with a dropbox access token, this class module can use Dropbox Python SDK API to do the above operations on Dropbox cloud.
    When use_localfs, use_dropbox = True, Flase, it reduces to os. method
    When use_localfs, use_dropbox = True, True,  it will write to both, but read from local

    Dropbox python API documentation:
    https://dropbox-sdk-python.readthedocs.io/en/latest/index.html

    
    self= LocalCloudHandler(True, True)
    rel_path = "/tmp2/d2"
    """
    #self.dbx=None

    def __init__(self, use_localfs = True, use_dropbox = False, 
                 local_prefix = "", cloud_prefix = "", 
                 dropbox_app_key: str, dropbox_app_secret: str,
                 sync_if_missing_file=False):
        logger.info(f"LocalCloud init... \n  Use Local HD: {use_localfs}, local_prefix = {local_prefix} ;\n  Dbx Cloud {use_dropbox}, mylc cloud_prefix = {cloud_prefix}.")    
        self.use_localfs  = use_localfs
        self.use_dropbox  = use_dropbox
        self.local_prefix = local_prefix
        self.cloud_prefix = cloud_prefix
        self.sync_if_missing_file = sync_if_missing_file
        self.dropbox_app_key = dropbox_app_key
        self.dropbox_app_secret = dropbox_app_secret
        #if not 'dbx' in globals():
        #    self.use_dropbox = False
        #    if use_dropbox:
        #        raise Exception("use_dropbox = True but no dbx instance is assigned")
        if self.use_dropbox:
            access_token = self.get_existing_dropbox_token()
            dbx = self.connect_dropbox(access_token)
            if dbx == None:
                self.use_dropbox = False; 
            else:
                self.dbx = dbx
        logger.info(f"Finished init. Dbx Cloud status {self.use_dropbox}")

    @staticmethod
    def _remove_doubleslash_endslash(rel_path):
        while '//' in rel_path:
            rel_path = rel_path.replace('//', '/')
        if rel_path.endswith("/"):
            rel_path = rel_path[:len(rel_path)-1]            
        return rel_path        
    
    def makedirs(self, rel_path):
        """Tested on both: DONE
        rel_path = '/text/edgar/by-index/abc'
        rel_path = '/text/edgar/'
        """
        rel_path = self._remove_doubleslash_endslash(rel_path)
        if self.use_localfs:
            local_full_path=self.local_prefix + rel_path
            if not os.path.exists(local_full_path):
                os.makedirs(local_full_path, exist_ok=True)
                logger.info(f"Make dir in local filesystem: {local_full_path}")
        if self.use_dropbox:
            cloud_full_path = self.cloud_prefix + rel_path    
            cloud_full_path = self._remove_doubleslash_endslash(cloud_full_path)
            #try: 
            #    metadata = dbx.files_get_metadata(cloud_full_path, include_media_info=True)
            try: 
                self.dbx.files_create_folder_v2(cloud_full_path)
                logger.info(f"Make dir in dbx-cloud filesystem: {cloud_full_path}")
            except dropbox.exceptions.ApiError as e:
                logging.error(f"Failed to create directory {cloud_full_path}, {str(e)}")
                    
    def rename(self, source, destination):
        """
        source = "/tmp/d1"
        destination = "/tmp/d3"
        Tested with dropbox
        """
        if self.use_localfs:
            if not os.path.exists(self.local_prefix + destination):
                # Move the file
                if os.path.exists(self.local_prefix + source):
                    os.rename(self.local_prefix + source, self.local_prefix + destination)
                    logger.debug("Local Move/Rename successful: {} -> {}".format(self.local_prefix + source, self.local_prefix + destination))
                else: 
                    logger.warning("Source {} does not exist. Move aborted.".format(self.local_prefix + source))    
            else:
                logger.warning("Destination {} already exists. Move aborted.".format(self.local_prefix + destination))    
        if self.use_dropbox:
            try:
                full_dest = self._remove_doubleslash_endslash(self.cloud_prefix + destination)                    
                full_from = self._remove_doubleslash_endslash(self.cloud_prefix + source)
                self.dbx.files_move(full_from, full_dest)
                logger.debug("Dbx Cloud Move/Rename successful: {} -> {}".format(full_from, full_dest))
            except dropbox.exceptions.ApiError as e:
                if isinstance(e.error, dropbox.files.RelocationError):
                    logger.warning("A conflict occurred. The destination already exists, or the source does not exist")
                else:
                    logger.critical("While trying to rename in Dropbox cloud, Undefined Exception occurred " + str(e))       
    
    def path_exists(self, rel_path ):
        """
        DEPRECIATED. 
        
        USE path_isfile or path_isdir instead
        rel_path = os.path.expanduser("~/Dropbox/Codes/")
        rel_path = '/text/edgar/full-index/1998-QTR4.csv.gz'
        rel_path='/text/edgar/by-index/'
        """
        logging.critical("Should not have called LocalCloud.path_exists(). Call LocalCloud.path_isfile() or LocalCloud.path_isdir() instead")
        return_value = False
        if self.use_localfs:
            local_full_path=self.local_prefix + rel_path
            local_return_value = os.path.exists(local_full_path)
            return_value =  return_value or local_return_value
            logger.debug(f"Local path_exists {local_full_path} local result: {local_return_value}")
        if not return_value:        
            if self.use_dropbox:
                cloud_full_path = self._remove_doubleslash_endslash(self.cloud_prefix + rel_path)
                try:
                    dbx_return_value = self.dbx.files_get_metadata(cloud_full_path)
                    logger.debug(f"Dbx Cloud path {cloud_full_path} exists.")
                    return_value = return_value or bool(dbx_return_value)
                except dropbox.exceptions.ApiError as e:
                    return_value =  return_value or  False
        return return_value
      
    def path_isfile(self, rel_path, check_onlyone_overrule = False):
        """
        rel_path = '/text/edgar/by-index/year2021_10k.csv'
        rel_path = "/text/edgar"
        self = mylc
        In general, when self.sync_if_missing_file = False, this function returns True as long as file exists in one place.
        When self.sync_if_missing_file =True, globally relative to the whole LocalCloud() instance, this function returns True only when files exist in both places; otherwise it will upload/download to make it happen when the file exists in only one place, and return False
        When check_onlyone_overrule = True, as long as file exists in one place before invoking this function, this function returns true, regardless of self.sync_if_missing_file and the upload/download action it may trigger within this function.
        Use check_onlyone_overrule = True for checking raw files directly from SEC to avoid redundant download when the file already exists in one place.
        """
        return_value, local_return_value, dbx_return_value = False, False, False
        local_full_path=self.local_prefix + rel_path
        cloud_full_path = self._remove_doubleslash_endslash(self.cloud_prefix + rel_path)
        if self.use_localfs:
            local_return_value =  os.path.isfile(self.local_prefix + rel_path)
            logger.debug(f"Local path_isfile {local_full_path} result: {local_return_value}")
        if self.sync_if_missing_file or not local_return_value:
            if self.use_dropbox:
                try:
                    #dbx_return_value = dbx.files_get_metadata(cloud_full_path)
                    metadata = self.dbx.files_get_metadata(cloud_full_path, include_media_info=True)
                    if  isinstance(metadata, dropbox.files.FileMetadata):
                        dbx_return_value = True
                        logger.debug(f"Dbx Cloud path_isfile exists: {cloud_full_path}")
                        if self.sync_if_missing_file and not local_return_value:
                            # Need to download from Dropbox to local
                            logger.debug(f"""Local file {local_full_path} not existing, but found in dropbox {cloud_full_path}. With --sync-if-missing-file, Start Downloading.""")
                            self.dbx_download(cloud_full_path, local_full_path)
                            logger.info(f"""Local file {local_full_path} not existing, but found in dropbox {cloud_full_path}. With --sync-if-missing-file, Finished Downloading.""")
                    elif isinstance(metadata, dropbox.files.FolderMetadata):
                        logger.info(f"Dbx Cloud path_isfile checking: {cloud_full_path} may exist but is a folder")    
                    else:
                        logger.info(f"Dbx Cloud path_isfile checking: {cloud_full_path} may exist but not a file")    
                except:
                    logger.debug(f"Dbx Cloud path_isfile checking FAILED: {cloud_full_path} ")    
                if self.sync_if_missing_file and self.use_localfs and not dbx_return_value:
                    # Need to Upload from local to dropbox.
                    logger.debug(f"""Local file {local_full_path}  existing, but not found in dropbox {cloud_full_path}. With --sync-if-missing-file, Start Reading local file.""")
                    cloud_parent_folder = os.path.join(*rel_path.split("/")[:-1])
                    if not self.path_isdir(cloud_parent_folder, check_both=True):
                        self.makedirs(cloud_parent_folder)
                    with open(local_full_path, "rb") as f:
                        bytes_data = f.read()
                        logger.debug(f"""Local file {local_full_path}  existing, but not found in dropbox {cloud_full_path}. With --sync-if-missing-file, Start Uploading local file.""")
                        self.dbx_upload(bytes_data, cloud_full_path)
                        logger.info(f"""Local file {local_full_path}  existing, but not found in dropbox {cloud_full_path}. With --sync-if-missing-file, Finished Uploading local file.""")
        if self.sync_if_missing_file:    
            return_value = local_return_value and dbx_return_value
        else:    
            return_value = local_return_value or dbx_return_value
        if check_onlyone_overrule:
            return_value = local_return_value or dbx_return_value
        return return_value
    
    def path_isdir(self, rel_path, check_both=False):
        return_value, local_return_value, dbx_return_value = False, False, False
        if self.use_localfs:
            local_full_path= self.local_prefix + rel_path
            local_return_value = os.path.isdir(local_full_path)
            logger.debug(f"Local path_isdir {local_full_path} result: {local_return_value}")
        if check_both or self.sync_if_missing_file or not local_return_value:      
            if self.use_dropbox :
                cloud_full_path=self._remove_doubleslash_endslash(self.cloud_prefix + rel_path)
                try:
                    #dbx_return_value = dbx.files_list_folder(cloud_full_path)
                    dbx_return_value = False
                    metadata = self.dbx.files_get_metadata(cloud_full_path, include_media_info=True)
                    if isinstance(metadata, dropbox.files.FolderMetadata):
                        logger.debug(f"Dbx Cloud path_isdir dbx-cloud result: {cloud_full_path}")
                        dbx_return_value = True
                except:
                    logger.debug(f"Dbx Cloud path_dir checking FAILED: {cloud_full_path} ")    
        if check_both or self.sync_if_missing_file:
            return_value = return_value and bool(dbx_return_value)
        else:    
            return_value = return_value or bool(dbx_return_value)
        return return_value
    
    def dbx_upload(self, f: bytes, dbx_full_path):
        while '//' in dbx_full_path:
            dbx_full_path = dbx_full_path.replace('//', '/')
        dbx_full_path = self._remove_doubleslash_endslash(dbx_full_path)
        use_dropbox = False
        if self.use_dropbox:
            use_dropbox = True
        elif "dbx" in globals():
            use_dropbox = True
        if use_dropbox:
            if len(f)< 150_000_000:
                self.dbx.files_upload(f, dbx_full_path, dropbox.files.WriteMode.overwrite)
            else: 
                logger.critical(f"Cannot upload to dropbox with size bigger than 150M: {dbx_full_path}") 
        else:
            logger.critical(f"use_dropbox = False but called dbx_upload() for file {dbx_full_path}")    

    def dbx_download(self, dbx_full_path, local_full_path = None):
        """
        read a file from dropbox cloud, and return it as bytes value, 
        if provided local_full_path, then saved as local file
        """
        dbx_full_path = self._remove_doubleslash_endslash(dbx_full_path)    
        use_dropbox = False
        if self.use_dropbox:
            use_dropbox = True
        elif "dbx" in globals():
            use_dropbox = True
        if use_dropbox:
            try:
                md, res = self.dbx.files_download(dbx_full_path)
                data = res.content
                logger.info(f"Read from dropbox cloud file {dbx_full_path}")
                if local_full_path:
                    with open(local_full_path, "wb") as file:
                        file.write(data)
                        logger.info(f"Save to local file {local_full_path}")
            except dropbox.exceptions.HttpError as err:
                logger.critical('***  dbx_download HTTP error', err)
        else:
            logger.critical("use_dropbox = False but called dbx_download()")    
        return data

    def write(self, data: Union[bytes, str], rel_path, use_gzip=False):
        """
        write(...) allows writing to both local storage and dropbox cloud;
        but writing to dropbox cloud only when file size less than 150M
        If not written to local nor dropbox cloud, raise an exception
        """
        upload_success = False
        if isinstance(data, str):
            data=data.encode(encoding="utf-8")
        if use_gzip:
            data_gzipped = gzip.compress(data) 
            if not rel_path.endswith("gz"):
                rel_path = "%s.gz" % rel_path
        else: 
            data_gzipped = data
        if self.use_localfs:
            local_full_path = self.local_prefix + rel_path
            with open(local_full_path, 'wb') as file:
                file.write(data_gzipped)
                logger.debug(f"Written file to local FS: {local_full_path}")
            upload_success = True    
        if self.use_dropbox:
            if len(data_gzipped) < 150_000_000:
                cloud_full_path = self._remove_doubleslash_endslash (self.cloud_prefix + rel_path)
                self.dbx_upload(data_gzipped, cloud_full_path) # will add self.cloud_prefix +  at dbx_upload
                logger.debug(f"Written file to cloud FS: {cloud_full_path}")
                upload_success = True
            if len(data_gzipped) >= 150_000_000:    
                logger.critical("File size over 150M, cannot write to Dropbox {self.cloud_prefix}{rel_path}")
        if not upload_success:
            logger.critical(f"use_localfs = False; Neither can write to dropbox {rel_path}")

    def read(self, rel_path, read_mode = "rt", use_gzip=False):
        """
        write(...)  allows writing to both local storage and dropbox cloud
        but  read() will try reading from local first if allowed; otherwise if allowed read from dropbox
        self = mylc
        rel_path = "/tmp/var1.txt.gz"
        """
        bytes_data, txt = bytes(), str()
        if self.use_localfs:
            with open(self.local_prefix + rel_path, 'rb') as file:
                bytes_data = file.read()  
        elif self.use_dropbox :
            dbx_full_path = self._remove_doubleslash_endslash (self.cloud_prefix + rel_path)
            bytes_data = self.dbx_download(dbx_full_path = dbx_full_path)
        else:
            logger.critical("use_localfs and use_dropbox are both False")    
        if use_gzip:
            decompressed_bytes = gzip.decompress(bytes_data)  
        else: 
            decompressed_bytes = bytes_data
        if read_mode=="rb":
            return decompressed_bytes
        else:
            txt = decompressed_bytes.decode('utf-8')
        return txt

    def sync_file(self, local_rel_path, cloud_rel_path, from_cloud_to_local = False):
        """This method has not been called anywhere?"""
        if self.use_localfs and self.use_dropbox:
            dbx_full_path = self._remove_doubleslash_endslash(self.cloud_prefix + cloud_rel_path)
            if from_cloud_to_local:
                self.dbx_download(dbx_full_path = dbx_full_path, local_full_path = self.local_prefix + local_rel_path )
            else: #from_local_to_cloud
                with open(self.local_prefix + local_rel_path, 'rb') as file:
                    bytes_data = file.read()  
                    self.dbx_upload(bytes_data,  dbx_full_path = dbx_full_path)
        else:
            logger.error("Cannot sync unless both local and cloud are turned on.")

    @staticmethod
    def get_existing_dropbox_token():
        """Attempt to obtain dropbox_token from 
            1. args
            2. stored file
        If neither is provided, return None
        """
        access_token = None

        if args.dropbox_access_token:
            access_token = args.dropbox_access_token  

        elif os.path.isfile("./.dropbox_access_token"):
            with open("./.dropbox_access_token", "r") as f:
                access_token = f.read()

        return access_token

    @staticmethod
    def authorize_dropbox_over_web(app_key: str, app_secret: str):
        #token_access_type (str) – the type of token to be requested. From the following enum:
        #None - creates a token with the app default (either legacy or online)
        #legacy - creates one long-lived token with no expiration
        #online - create one short-lived token with an expiration
        #offline - create one short-lived token with an expiration with a refresh token
        auth_flow = dropbox.oauth.DropboxOAuth2FlowNoRedirect(app_key, app_secret, token_access_type="offline")
        authorize_url = auth_flow.start()
        logger.info("Please authorize the app by visiting this URL:", authorize_url)
        print("Please authorize the app by visiting this URL:", authorize_url)
        auth_code = input("Enter the authorization code: ")

        oauth_result = auth_flow.finish(auth_code)
        access_token = oauth_result.access_token
        with open("./.dropbox_access_token", "wt") as f:
            f.write(access_token)
        print(f"Dropbox Account Authorization of App with app-key {app_key} completed!")    
        return access_token

    def connect_dropbox(self, access_token = None, retrying_already = False):
        """
        Setup Dropbox Connection
        You need to apply for a Dropbox APP, then get an API token from Dropbox app console
        Dropbox app console: https://www.dropbox.com/developers/apps?_tk=pilot_lp&_ad=topbar4&_camp=myapps

        To assign dropbox token: 
        * Either run in console: export DBX_TOKEN = ${your_token}
            Shortened example: export DBX_TOKEN=sl.BeoSWaH2atxxxxtm-4 
        Or include it in the parameter --

        See Dropbox Python API Documentation: https://dropbox-sdk-python.readthedocs.io/en/latest/
        """
        if access_token==None: 
            access_token = self.authorize_dropbox_over_web(self.dropbox_app_key, self.dropbox_app_secret)
        dbx = dropbox.Dropbox(access_token)
        try:
            account = dbx.users_get_current_account()
            logger.info("Connected to Dropbox successfully! ")
            #logger.info(f"Account information: {account}")
        except dropbox.exceptions.AuthError as e:
            if retrying_already:
                logging.critical("CANNOT ACCESS DROPBOX")
                dbx = None
            else:    
                dbx = self.connect_dropbox(access_token = None, retrying_already=True)
        return dbx

